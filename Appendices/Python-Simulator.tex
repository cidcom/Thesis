%!TEX root = /Users/jakubkonka/Thesis/Thesis.tex
\chapter{Py3k Discrete-Event System Simulator}
\label{cha:py3k_discrete_event_system_simulator}

\minitoc
\vspace{10mm}

The discrete-event system (DES) simulation study outlined in Chapter~\ref{cha:dynamics_of_network_selection_in_the_digital_marketplace} was conducted using software that was developed during this research from scratch in Python programming language, version 3 (Py3k). Py3k was chosen mainly due to the fact that it is a dynamically-typed language which makes prototyping quicker than in a statically-typed language such as C++. This allows the researcher to focus more on the design and results of the experiment rather than its implementation. Furthermore, Py3k features a set of libraries that further simplify the implementation stage of the DES simulation; for example, \lstinline{subprocess} module allows the execution of multiple simulation runs in parallel~\cite{Py3kSubprocess}, while \lstinline{numpy}, \lstinline{scipy}, and \lstinline{matplotlib} modules provide a set of convenience routines for numerical computation and scientific plotting in Py3k~\cite{Numpy, Scipy, Matplotlib}. On the other hand, since Py3k is an interpreted language, it can potentially be slower in execution time and less memory efficient than a compiled language such as C++~\cite{Py3kC++}; however, it does not visibly increase the overall cost of the simulation study since the computer resources are inexpensive.

The software is released under the MIT License, and is available for download on Github: \url{https://github.com/kubkon/des-in-python}.

\section{Description of the Simulator}
\label{sec:description_of_the_simulator_simappendix}

\subsection{High-level Overview}
\label{sub:high_level_overview_simappendix}
The simulator is composed of four building blocks: \lstinline{SimulationEngine} class, \lstinline{EventHandler} class, \lstinline{Event} class, and \lstinline{PRNG} class. The \lstinline{SimulationEngine} class provides all the core functionality of a DES simulator. It advances the simulation time, and implements the event list. The \lstinline{EventHandler} class is an abstract base class (or an interface), and provides an outline of the basic functionality that any proper subclass must implement. In general, it is responsible for generating and handling simulation specific events; for example, customer arrival and departure events in a simulation of an M/M/1 queue. The \lstinline{Event} class implements basic structure of a generic event used by the simulator. Finally, the \lstinline{PRNG} class provides basic pseudo-random number generation (PRNG) routines, and currently, it is a wrapper class for the Py3k \lstinline{random} module.

\begin{figure}[t]
  \includegraphics[width=3in]{Appendices/Figures/simulation_flow}
  \caption{Simplified simulation flow}
  \label{fig:simulation_flow_simappendix}
\end{figure}

Figure~\ref{fig:simulation_flow_simappendix} depicts the simplified flow of the simulation. Upon the start of the simulation, a \lstinline{SimulationEngine} class instance notifies an \lstinline{EventHandler} class instance\footnote{Technically, a \lstinline{SimulationEngine} class instance notifies an instance of a class that subclasses the \lstinline{EventHandler} class; however, to keep the description simple and generic, we shall refer to it as an \lstinline{EventHandler} class instance.} of the start of the simulation (via a callback mechanism). At this point, the \lstinline{EventHandler} class instance should handle it by generating the first event, and passing it to the \lstinline{SimulationEngine} class instance for scheduling. Afterwards, the \lstinline{SimulationEngine} class instance dequeues the next event from the event list, and passes it to the \lstinline{EventHandler} class instance, which should update statistics related to the passed in event, and generate additional events. The process is repeated until there are no events in the event list. When the list becomes empty, the \lstinline{SimulationEngine} class instance notifies the \lstinline{EventHandler} class instance of the stop of the simulation. At this point, the \lstinline{EventHandler} class instance should save/finalize all the statistics relevant to the simulation for further processing and analysis.

\subsection{SimulationEngine Class}
\label{sub:simulationengine_class_simappendix}
As briefly mentioned in Section~\ref{sub:high_level_overview_simappendix}, the \lstinline{SimulationEngine} class provides all the core functionality of a DES simulator. In particular, the class defines the following attributes:
\begin{itemize}
  \item \lstinline{self.simulation_time} stores the current simulation time. The simulation time is assumed to be in seconds; thus, \lstinline{self.simulation_time = 1} is equivalent to setting the simulation time to 1 second.
  \item \lstinline{self.prng} stores a reference to a PRNG. By default, \lstinline{self.prng = PRNG()}; that is, it references an instance of the \lstinline{PRNG} class.
  \item \lstinline{self.event_handler} stores a reference to an event handler; i.e., an instance of a class that subclasses the \lstinline{EventHandler} class. If \lstinline{self.event_handler} is unassigned in the main simulation script, then an exception is raised.
\end{itemize}

The basic use of the \lstinline{SimulationEngine} class in the main simulation script is depicted in Listing~\ref{listing:excerpt_from_main_simulation_script_simappendix}. In the listing, it is assumed that the definition of the \lstinline{SimulationEngine} class resides in the \lstinline{sim} module which, in turn, is part of the \lstinline{modules} subpackage of the \lstinline{simulator} package (line 1, Listing~\ref{listing:excerpt_from_main_simulation_script_simappendix}). Furthermore, it is assumed that \lstinline{event_handler} variable was defined somewhere else in the script, and that it is an instance of a class that subclasses the \lstinline{EventHandler} class (line 9, Listing~\ref{listing:excerpt_from_main_simulation_script_simappendix}).
\begin{lstlisting}[caption=Excerpt from main simulation script, label=listing:excerpt_from_main_simulation_script_simappendix]
import simulator.modules.sim as sim

...

### Initialize
# Create new simulation engine
se = sim.SimulationEngine()
# Attach event handler to the simulation engine
se.event_handler = event_handler

### Simulate
# Schedule finishing event at 100s
se.stop(100)
# Start simulating
se.start()
\end{lstlisting}
The simulation is started by calling the \lstinline{start()} member method of the \lstinline{SimulationEngine} class (line 15, Listing~\ref{listing:excerpt_from_main_simulation_script_simappendix}). However, it is necessary to call the \lstinline{stop(finish_time)} member method beforehand in order to specify the duration of the simulation (line13, Listing~\ref{listing:excerpt_from_main_simulation_script_simappendix}).

\begin{lstlisting}[caption=\lstinline{stop(finish_time)} member method of the \lstinline{SimulationEngine} class, label=listing:stop_member_method_simulationengine_simappendix]
def stop(self, finish_time):
  """
  Schedules finishing event

  Arguments:
  finish_time -- Time of occurrence of the finishing event
  """
  # Check if finishing event already scheduled
  if not self._finish_event_exists:
    # Set finish time
    self._finish_time = finish_time
    # Schedule finishing event
    self._event_list += [Event(self.END_EVENT, self._finish_time)]
    self._finish_event_exists = True
\end{lstlisting}

Listing~\ref{listing:stop_member_method_simulationengine_simappendix} depicts the implementation of the \lstinline{stop(finish_time)} member method, while Listing~\ref{listing:start_member_method_simulationengine_simappendix} presents the implementation of the \lstinline{start()} member method. The \lstinline{stop(finish_time)} method schedules an end event (i.e., appends it to the event list, \lstinline{self._event_list}) for the simulation of duration equal to \lstinline{finish_time} (line 13, Listing~\ref{listing:stop_member_method_simulationengine_simappendix}) if it was not already scheduled by checking the state of the flag member variable \lstinline{self._finish_event_exists} (line 9, Listing~\ref{listing:stop_member_method_simulationengine_simappendix}).

\begin{lstlisting}[caption=\lstinline{start()} member method of the \lstinline{SimulationEngine} class, label=listing:start_member_method_simulationengine_simappendix]
def start(self):
  """
  Starts simulation
  """
  # Check if an event handler is attached; if not, throw an error
  if not self.event_handler:
    raise Exception("No EventHandler attached!")
  # Notify of the start of the simulation; event handlers should
  # generate first event
  self._notify_start()
  # Traverse the event list
  while len(self._event_list) > 0:
    # Remove the imminent event from the event list
    imminent = self._event_list.pop()
    # Advance clock to the imminent event
    self.simulation_time = imminent.time
    # Notify of the current event
    self._notify_event(imminent)
  # Notify of the end of the simulation
  self._notify_stop()
\end{lstlisting}

\begin{lstlisting}[caption=\lstinline{schedule(event)} member method of the \lstinline{SimulationEngine} class, label=listing:schedule_member_method_simulationengine_simappendix]
def schedule(self, event):
  """
  Schedules event (adds it to event list)

  Arguments:
  event -- Event to be scheduled
  """
  # Discard new event if happens after the finishing event
  if event.time < self._finish_time:
    # Add the event to the event list
    self._event_list += [event]
    # Sort the list in a LIFO style
    self._event_list.sort(key=lambda x: x.time)
    self._event_list.reverse()
\end{lstlisting}

\subsection{EventHandler Class}
\label{sub:eventhandler_class_simappendix}

\subsection{Event Class}
\label{sub:event_class_simappendix}

\subsection{PRNG Class}
\label{sub:prng_class_simappendix}

\section{Validation of the Simulator}
\label{sec:validation_of_the_simulator_simappendix}
Since the simulation engine is not part of any known simulation package and was written from scratch, it should be validated prior to conducting any complex simulation study. To this end, the validation stage comprises simulation of a simple first-in first-out (FIFO) network link modeled as an M/M/1 queue, and analysis of steady-state average packet delay in the system (Figure~\ref{fig:mm1_queue_simappendix}). The M/M/1 queue was chosen since it is simple to implement, and the simulation results can directly be verified by comparison with the theoretical prediction.

\begin{figure}[t]
	\includegraphics[width=3in]{Appendices/Figures/mm1_queue}
	\caption{Illustration of M/M/1 queuing model}
	\label{fig:mm1_queue_simappendix}
\end{figure}

\subsection{MM1EventHandler Class}
\label{sub:mm1eventhandler_class_simappendix}

\subsection{Simulation Results and Analysis}
\label{sub:simulation_results_and_analysis_simappendix}
As a quick reminder of basic queueing theory, M/M/1 queue denotes a single-server queueing system with exponential interarrival times and service times, and a FIFO queue discipline. For a proper, more in-depth treatment of queueing theory, see for example~\cite{CassandrasLafortune2008}. Let $\lambda\in\mathbb{Z}_+$ denote the mean interarrival rate, and let $\mu\in\mathbb{Z}_+$ denote the mean service rate such that $0 \le \lambda < \mu$. The steady-state mean packet delay in an M/M/1 queueing system can thus be defined as follows
\begin{equation}
	\label{eq:mm1_mean_packet_delay_simappendix}
	T = \frac{1}{\mu - \lambda},\quad T\in\displaystyle\left[\frac{1}{\mu}, \infty\right).
\end{equation}
Let $\rho = \displaystyle\frac{\lambda}{\mu}$ denote the mean link (or system) utilization. Clearly, $\rho\in [0,1)$. Hence, the steady-state mean packet delay in Equation~\eqref{eq:mm1_mean_packet_delay_simappendix} can be rewritten as
\begin{equation}
	\label{eq:mm1_mean_packet_delay_2_simappendix}
	T(\rho) = \frac{1}{\mu(1 - \rho)}.
\end{equation}

\begin{table}[p!]
	\caption{Simulation estimated M/M/1 queue steady-state average packet delay}
	\begin{tabular*}{0.5\columnwidth}[L]{@{\extracolsep{\fill}}c c c}
		\hlx{vhv}
		\textbf{Average} & \multicolumn{2}{c}{\textbf{Average packet delay, s}} \\
		\textbf{link utilization} & Mean & $95\%$ confidence interval (x $10^{-5}$) \\
		\hlx{vhv}
		 $0.1$	& $0.02224$	& $4.38835$\\
		 $0.2$	& $0.02497$	& $3.88310$\\
		 $0.3$	& $0.02858$	& $4.32400$\\
		 $0.4$	& $0.03333$	& $6.22518$\\
		 $0.5$	& $0.03999$	& $7.67952$\\
		 $0.6$	& $0.04997$	& $13.62042$\\
		 $0.7$	& $0.06654$	& $22.25786$\\
		 $0.8$	&	$0.10025$	& $51.73063$\\
		 $0.9$	& $0.20100$	& $192.24667$\\
		 \hlx{vhs}
	\end{tabular*}
	\label{tab:mm1_simulation_results_simappendix}
\end{table}
\begin{figure}[p!]
	\includegraphics[width=\figsize]{Appendices/Figures/mm1_simulation_results}
	\caption{Comparison of M/M/1 queue simulation results with the theory}
	\label{fig:mm1_simulation_results_simappendix}
\end{figure}

The queueing system was simulated with the following parameters: $\mu=50$ packets per second (pps), and $\lambda\in\{5,10,\ldots,45\}$ pps which is equivalent to $\rho\in\{0.1,0.2,\ldots,0.9\}$. The objective of the simulation was to estimate the steady-state mean packet delay, $T(\rho)$, for each value of the mean link utilization, $\rho$. To this end, for each value of $\rho$, the system was simulated for 1 hour, and a simulation run was replicated 100 times with different seeds to the pseudo-random number generator (PRNG). In all simulation runs, the buffer was initially empty; i.e., there were no packets in the queue. The output of each simulation run constituted a time-series of packet delays in the system. Since the simulation is inherently a nonterminating simulation, the estimation of the steady-state mean packet delay consisted of two steps: 1)~removal of the transient (or warm-up) response of the system, and 2)~averaging within and across the replications with transient response removed. The removal of the transient response was facilitated through the use of the Welch's method~\cite{LawChapter92007}, and for each value of $\rho$, the transient response covered approximately the initial 2000 packet delay samples.

Table~\ref{tab:mm1_simulation_results_simappendix} depicts the estimated steady-state average packet delay for each value of the average link utilization, $\rho$. In all cases, the mean value of the average packet delay closely converges to the theoretical prediction; this conclusion is emphasized in Figure~\ref{fig:mm1_simulation_results_simappendix}. Furthermore, the 95\% confidence interval for the mean of average packet delay does not exceed the factor of $10^{-3}$ for any value of the average link utilization. All in all, this successfully validates the DES simulation engine.

